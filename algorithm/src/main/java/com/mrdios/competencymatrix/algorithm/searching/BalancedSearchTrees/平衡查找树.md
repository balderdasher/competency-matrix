平衡查找树是一种二分查找树并能保证无论如何构造它，它的运行时间都是对数级别的。

## 2-3 查找树 ##
> 为保证查找树的平衡性，我们需要一些灵活性，因此需要允许树中的一个结点保存多一个键。

**定义**. 一棵2-3查找树或为一棵空树，或由以下结点组成：
- 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
- 3-结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。

我们将指向一棵空树的链接称为空链接

![23tree-anatomy](http://i.imgur.com/wEIm75M.png)

**查找**. 要判断一个键是否在树中，我们先将它和根结点中的键比较，如果它和其中任意一个相等，查找命中；否则就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是一个空链接，查找未命中，如下图所示：
![23tree-search](http://i.imgur.com/QPqfu7x.png)

**向2-结点中插入新键**. 要在2-3树中插入一个新结点，我们可以和二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部，但是这样无法保持完美平衡性，使用2-3树的主要原因就在于它能够在插入后继续保持平衡。如果未命中的查找结束于一个2-结点，我们只要把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可，如果未命中的查找结束于一个3-结点就要麻烦一些。

![23tree-insert2](http://i.imgur.com/sqlnAiG.png)

**向一棵只含有一个3-结点的树中插入新键**. 假设我们需要向一棵只含有一个3-结点的树中插入一个新键。这棵树中有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。为了将新键插入，我们先临时将新键存入该结点中，使之成为一个4-结点。它很自然地扩展了以前的结点并含有3个键和4条链接。创建一个4-结点很方便，因为很容易将它替换为一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。这棵树既是一棵含有3个结点的二叉查找树，同时也是一棵完美平衡的2-3树，因为其中所有的空链接到根结点的距离都相等，插入前树的高度为0，插入后树的高度为1，这也说明了2-3树是如何生长的，如下图所示：

![23tree-insert3a](http://i.imgur.com/Hshmwu0.png)

**向一个父节点为2-结点的3-结点中插入新键**. 假设未命中的查找结束于一个3-结点，而它的父结点时一个2-结点。此时我们需要在*维持树的完美平衡的前提下*为新键腾出空间。我们先构造一个临时的4-结点并将其分解，但此时不会为中键创建一个新结点，而是将其移动至原来的父结点中。可以将这次转换看成将指向原3-结点的一条链接替换为新父结点中的原中键左右两边的两条链接，并分别指向两个新的2-结点。根据假设，父结点中是有空间的：父结点是一个2-结点（一个键两条链接），插入后变为了一个3-结点（两个键三条链接）。另外，这次转换也不影响（完美平衡的）2-3树的性质，树仍然是有序的，因为中键被移动到父结点中去了；树仍然是完美平衡的，插入后所有的空链接到根结点的距离仍然相同。如下图所示：

![23tree-insert3b](http://i.imgur.com/ThdaFrk.png)

**向一个父结点为3-结点的3-结点中插入新键**. 假设未命中的查找结束语一个父结点为3-结点的结点。我们再次和上面一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点中也是一个3-结点，因此再用这个中键构造一个新的临时4-结点，然后*在这个结点上进行相同的变换*，即分解这个父结点并将它的中键插入到它的父结点中去，推广到一般情况，就这样一直向上不断地分解临时的4-结点并将中键插入更高层的父结点中，直到遇到一个2-结点并将它替换为一个不需要继续分解的3-结点或者是到达3-结点的根。如下图：

![23tree-insert3c](http://i.imgur.com/Snx6VnN.png)

**分解根结点.** 如果从插入结点到根结点的路径上全是3-结点，那么根结点最终变成一个临时的4-结点。此时我们可以按照向一棵只有3-结点的树中插入新键的方法处理此问题。将临时的4-结点分解为3个2结点，使得树高加1，这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根结点。如下图所示：

![23tree-split](http://i.imgur.com/5GgVQyZ.png)

**局部变换.** 将一个结点分解为一棵2-3树可能有6种情况，2-3树插入算法的根本在于这些变换都是`局部的`：除了相关的结点和链接之外不必修改或检查树的其他部分。每次变换中，变更的链接数量不会超过一个很小的常数，不光是在树的底部，树中的`任何地方`只要符合相应的模式，变换都可以进行。每个变换都会将4-结点中的一个键送入它的父结点中，并重构相应的链接而不涉及树的其他部分。

![23tree-locals](http://i.imgur.com/HQ0oZtw.png)

**全局性质.** 局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。

**小结：** 在一棵大小为`N`的2-3树中，查找和插入操作访问的结点必然不超过`lgN`个。

## 红黑二叉查找树 ##

> 2-3树的插入算法并不难理解也不难实现，一种名为`红黑二叉查找树`的简单数据结构可以用来表达并实现它。

**替换3-结点.** 红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。可以将树中的链接分为两种类型：`红链接`将两个2-结点连接起来构成一个3-结点，`黑链接`则是2-3树中的普通链接（两个2-结点其中之一是另一个的左子结点）相连的两个2-结点，如下图所示，这种表示法的一个优点是，`无需修改`就可以直接使用标准的二叉查找树的`get()`方法
。对于任意的2-3树，只要对结点进行转换，都可以立即派生出一棵对应的二叉查找树，我们将用这种方法表示2-3树的二叉查找树称为`红黑二叉查找树`，简称`红黑树`。

![redblack-encoding](http://i.imgur.com/tX3eDkh.png)

**一种等价的定义.** 红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：
- 红链接为左链接
- 没有任何一个结点同时和两条红链接相连
- 该树是`完美黑色平衡`的，即任意空链接到根结点的路径上的黑链接数量相同

**一一对应.** 如果将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都是相同的，如果将由红链接相连的结点合并，得到的就是一棵2-3树

![redblack-1-1](http://i.imgur.com/nqNOxmK.png)

**颜色表示.** 因为每个结点都有一个指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点的`Node`数据类型的布尔变量`color`中，如果指向它的链接为红色此变量为`true`，黑色则为`false`，约定空链接为黑色。

![redblack-color](http://i.imgur.com/8l2vHLZ.png)

**旋转.** 在实现中的某些操作可能会出现红色右链接或者连续的红链接，但在操作完成前这些情况都会被`旋转`修复，旋转操作会改变红链接的指向。红色的右链接转化为左链接的操作称为`左旋转`，
反之称为`右旋转`。

![redblack-left-rotate](http://i.imgur.com/6KGUadd.png)![redblack-right-rotate](http://i.imgur.com/8542RVt.png)

**颜色转换.** 颜色转换方法`flipColor()`用来转换一个结点的两个红色子结点的颜色。除了将子结点的颜色由红变黑之外，同时还要将父结点堆的颜色由黑变红。这项操作是局部变换，不会影响整棵树的黑色平衡性。

![color-flip](http://i.imgur.com/v7BTXuN.png)

**根结点总是黑色的.** 颜色转换会使根结点变为红色，这也可能出现在很大的红黑树中。严格来说，红色的根结点说明根结点是一个3-结点的一部分，但实际情况并不是这样，因此再每次插入后都会将根结点设为黑色，每当根结点由红变黑时树的黑链接高度就会加1。

红黑树的构造轨迹：

![redblack-construction](http://i.imgur.com/2qtkqcw.png)