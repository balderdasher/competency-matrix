### 15.1 泛型的出现 ###

#### 15.1.1 为什么要用泛型 ####

一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果需要编写可以应用于多种类型的代码。这种刻板的限制对代码的束缚就很大。所以从Java SE5开始，泛型出现了，泛型实现了**参数化类型**的概念，使代码可以应用于多种类型。

#### 15.1.2 什么是泛型 ####

泛型这个术语的意思是：“适用于许多许多的类型”，就是一种宽泛的类型，适用于很多的类型。

泛型可以用于类、接口、方法等

### 15.2 泛型类 ###

有时候，我们希望一个类可以用于不同类型的对象，通常而言，在使用时用来表示一种类型的对象，泛型就可以用来指定这个类用于什么类型的对象，而且由编译器来保证类型的正确性。

遇到上面的需求时，通常我们会暂时不指定类型，而是稍后使用的时候再决定使用什么类型，要达到这个目的就需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换此参数类型，下面的例子中，T就是类型参数：

```java
/**
 * 泛型类
 *
 * @author huxiong
 * @date 2016/07/07 15:17
 */
public class GenericClass<T> {
    private T field;

    public T getField() {
        return field;
    }

    public void setField(T field) {
        this.field = field;
    }

    @Override
    public String toString() {
        return "GenericClass{" +
                "field=" + field +
                '}';
    }

    public static void main(String[] args) {
        GenericClass<String> s = new GenericClass<>();
        s.setField("gaga");
        System.out.println("s：" + s);
        GenericClass<Integer> i = new GenericClass<>();
        i.setField(100);
        System.out.println("i：" + i);
    }
}

输出：
s：GenericClass{field=gaga}
i：GenericClass{field=100}
```
GenericClass类可以用于任意类型的对象，它是一个泛型类，我们只要在使用的时候指定其具体类型就可以了。

### 15.3 泛型接口 ###

同样，泛型也可以用于接口，例如`生成器`，这是一种专门负责创建对象的类，这也是`工厂方法设计模式`的一种应用，不过在使用时，不需要任何参数，下面是一个制造玩具的程序：

```java
/**
 * 生产接口
 *
 * @param <T>
 */
interface Builder<T> {
    T next();
}

/**
 * 玩具
 */
class Toy {
    private static long counter = 0;
    private final long id = counter++;

    @Override
    public String toString() {
        return getClass().getSimpleName() + id;
    }
}

/**
 * 玩具狗
 */
class DogToy extends Toy {
}

/**
 * 玩具猫
 */
class CatToy extends Toy {
}

/**
 * 玩具熊
 */
class BearToy extends Toy {
}

/**
 * 玩具制造器
 */
class ToyBuilder implements Builder<Toy>, Iterable<Toy> {
    private Class[] types = {DogToy.class, CatToy.class, BearToy.class};
    private int size = 0;//for iteration
    private final Random rand = new Random(47);

    public ToyBuilder() {
    }

    public ToyBuilder(int size) {
        this.size = size;
    }

    @Override
    public Toy next() {
        try {
            // make a toy randomly
            return (Toy) types[rand.nextInt(types.length)].newInstance();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 自定义迭代器
     */
    class ToyIterator implements Iterator<Toy> {
        int count = size;

        @Override
        public boolean hasNext() {
            return count > 0;
        }

        @Override
        public Toy next() {
            count--;
            return ToyBuilder.this.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    @Override
    public Iterator<Toy> iterator() {
        return new ToyIterator();
    }

    public static void main(String[] args) {
        ToyBuilder tb = new ToyBuilder();
        for (int i = 0; i < 3; i++) {
            System.out.println(tb.next());
        }
        System.out.println("------------------------");
        for (Toy t : new ToyBuilder(3)) {
            System.out.println(t);
        }
    }
}

输出：
BearToy0
BearToy1
CatToy2
------------------------
BearToy3
BearToy4
CatToy5
```

### 15.4 泛型方法 ###

泛型方法所在的类可以是泛型类也可以不是泛型类，也就是说是否拥有泛型方法，与其所在的类是否是泛型没有关系。

泛型方法的定义就是将泛型参数列表置于返回值之前，像这样：

```java
/**
 * 泛型方法
 * @author huxiong
 * @date 2016/07/07 15:00
 */
public class GenericMethod {
    public <T> void f(T x){
        System.out.println(x.getClass().getName());
    }

    public static void main(String[] args) {
        GenericMethod gm = new GenericMethod();
        gm.f("baby");
        gm.f(1);
        gm.f(3.0f);
        gm.f(5.0d);
        gm.f(gm);
    }
}

输出：
java.lang.String
java.lang.Integer
java.lang.Float
java.lang.Double
com.mrdios.competencymatrix.java.readingnotes.ThinkingInJava.chapter15.GenericMethod
```

通过程序我们看到，当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法时通常不需要，因为编译器会为我们找出正确的类型。这成为**类型参数推断**

