### 深入研究容器的意义 ###

* 学习散列机制是如何工作的
* 在使用散列容器时怎样编写`hashCode()`和`equals()`方法
* 为什么某些容器有不同版本的实现以及如何选择它们

### 17.1 完整的容器分类法 ###

完整的容器图

![full](http://i.imgur.com/bY03QpW.png)

### 17.2 填充容器 ###

Collections容器工具类中的填充方法

* `Collections.nCopies()`
* `Collections.fill()`

以上两种填充方式都只是复制一个对象引用来填充整个容器，并且只对`List`对象有用。

### 17.3 散列与散列码 ###

正确的`equals()`方法必须满足一下5个条件：

1. 自反性：对任意`x`,`x.equals(x)`一定返回true
2. 对称性：对任意`x`和`y`，如果`y.equals(x)`返回true，则`x.equals(y)`也返回true
3. 传递性：对任意`x`、`y`、`z`，如果有`x.equals(y)`返回true，`y.equals(z)`返回true，则`x.equals(z)`一定返回true
4. 一致性：对任意`x`和`y`，如果对象中用于等价比较的信息没有改变，那么无论调用`x.equals(y)`多少次，返回的结果应该保持一致，要么一直是true，要么一直是false
5. 对任何不适`null`的`x`，`x.equals(null)`一定返回false

**默认的`Object.equals()`只是比较对象的地址**，所以一个`Stu`并不等于另一个`Stu`。

#### 17.3.1 理解hashCode() ####

首先，使用散列的目的在于：想要使用一个对象来查找另一个对象，下面是一个使用一对`ArrayList`实现的`Map`，包含了Map接口的完整实现，因此提供了`entrySet()`方法：

```java

public class SlowMap<K,V> extends AbstractMap<K,V> {
    private List<K> keys = new ArrayList<>();
    private List<V> values = new ArrayList<>();

    @Override
    public V put(K key, V value) {
        V oldValue = get(key);
        if (!keys.contains(key)){
            keys.add(key);
            values.add(value);
        }else{
            values.set(keys.indexOf(key),value);
        }
        return oldValue;
    }

    @Override
    public V get(Object key) {
        if (!keys.contains(key)){
            return null;
        }
        return values.get(keys.indexOf(key));
    }

    @Override
    public Set<Map.Entry<K, V>> entrySet() {
        Set<Map.Entry<K,V>> set = new HashSet<>();
        Iterator<K> ki = keys.iterator();
        Iterator<V> vi = values.iterator();
        while (ki.hasNext()){
            set.add(new MapEntry<K, V>(ki.next(),vi.next()));
        }
        return set;
    }

    class MapEntry<K,V> implements Map.Entry<K,V>{
        private K key;
        private V value;

        public MapEntry(K key, V value) {
            this.key = key;
            this.value = value;
        }

        @Override
        public K getKey() {
            return key;
        }

        @Override
        public V getValue() {
            return value;
        }

        @Override
        public V setValue(V v) {
            V result = v;
            value = v;
            return result;
        }

        @Override
        public int hashCode() {
            return (key == null ? 0 : key.hashCode())^
                    (value == null ? 0 : value.hashCode());
        }

        @Override
        public boolean equals(Object obj) {
            if (!(obj instanceof MapEntry)){
                return false;
            }
            MapEntry me = (MapEntry) obj;
            return (key == null?me.getKey() == null:key.equals(me.getKey()))
                    && (value == null?me.getValue() == null:value.equals(me.getValue()));
        }

        @Override
        public String toString() {
            return key + "=" + value;
        }
    }

    public static void main(String[] args) {
        SlowMap<String,String> map = new SlowMap<>();
        map.put("a","a");
        map.put("b","b");
        System.out.println(map);
    }
}
```

SlowMap说明创建一个新的Map并不难，但是正如其名字所示，它并不快，问题在于对键的查询，键没有按照任何特定顺序保存，所以只能使用简单的线性查询，而线性查询是最慢的查询方式。

散列的价值在于速度：散列使得查询得以快速进行，由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的顺序状态，然后使用`Collection.binarySearch()`进行查询。

散列则更进一步，它将键保存在某处，以便能够快速找到。存储一组元素最快的数据结构是数组，所以使用数组来表示键的信息（键的信息，不是键本身），但是因为数组不能够扩容，因此就有一个问题：我们希望在Map中保存数量不确定的值，但是如果键的数量被数组容量限制了又该怎么办呢？

答案就是：数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是**散列码**，由散列函数`hashCode()`生成。

所以可以说：**散列码就是在Map中的键对象在其保存键信息的数组中的下标数字**。

为解决数组容量被固定的问题，不同的键可以产生相同的下标，也就是说，散列码可能会有*冲突*。因此，数组多大已经不重要了，任何键总能在数组中找到它的位置。

于是，在map中查询一个值的过程首先就是计算散列码，然后使用散列码查询数组，如果能够保证没有冲突（只有值的数量是固定时才有可能），那就可以有一个*完美的散列函数*，但是这种情况只是特例（EnumMap和EnumSet中得到了实现）。通常，冲突由外部连接处理：数组并不直接保存值，而是保存值的`list`。然后对list中的值使用`equals()`方法进行线性的查询。这部分的查询会比较慢，但是如果散列函数好的话，数组的每个位置就只有较少的值，因此不是查询整个list，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这就是`HashMap`会如此快的原因。

根据以上关于散列的原理，就可以实现如下一个简单的散列Map了：

```java
public class SimpleHashMap<K,V> extends AbstractMap<K,V> {
    // 指定一个质数作为哈希表的长度，用于获得均匀分布
    static final int SIZE = 997;

    // 用于存放值list的数组，即散列表
    LinkedList<MapEntry<K,V>>[] buckets = new LinkedList[SIZE];

    @Override
    public V put(K key, V value) {
        V oldValue = null;
        // 计算该值要存放在数组中的哪个位置
        int index = Math.abs(key.hashCode()) % SIZE;
        // 该位置可用则在此位置初始化存储空间
        if (buckets[index] == null){
            buckets[index] = new LinkedList<MapEntry<K,V>>();
        }
        // 待放入的bucket
        LinkedList<MapEntry<K,V>> bucket = buckets[index];
        // 构造键值对
        MapEntry<K,V> pair = new MapEntry<>(key,value);

        boolean found = false;
        // 在数组中对应下标的list中查找key，若存在相同的key则替换旧值
        ListIterator<MapEntry<K,V>> it = bucket.listIterator();
        while (it.hasNext()){
            MapEntry<K,V> iPair = it.next();
            if (iPair.getKey().equals(key)){
                oldValue = iPair.getValue();
                it.set(pair); // 替换旧值
                found = true;
                break;
            }
        }
        // 为查到key则在数组相应位置中的list中放入此键值对
        if (!found){
            buckets[index].add(pair);
        }
        return oldValue;
    }

    @Override
    public V get(Object key) {
        // 先根据key确定在数组中定位查询范围
        int index = Math.abs(key.hashCode()) % SIZE;
        if (buckets[index] == null){
            return null;
        }
        // 在确定的查询范围中根据key查询查到则返回值
        for (MapEntry<K,V> iPair:buckets[index]){
            if (iPair.getKey().equals(key)){
                return iPair.getValue();
            }
        }
        return null;
    }

    @Override
    public Set<Entry<K, V>> entrySet() {
        Set<Entry<K,V>> set = new HashSet<>();
        for (LinkedList<MapEntry<K,V>> bucket : buckets){
            if (bucket == null){
                continue;
            }
            for (MapEntry<K,V> mpair : bucket){
                set.add(mpair);
            }
        }
        return set;
    }

    public static void main(String[] args) {
        SimpleHashMap<String,String> m = new SimpleHashMap<>();
        m.put("a","a");
        m.put("b","b");
        System.out.println(m);
        System.out.println(m.get("a"));
        System.out.println(m.entrySet());
    }
}

输出：
{a=a, b=b}
a
[a=a, b=b]
```


